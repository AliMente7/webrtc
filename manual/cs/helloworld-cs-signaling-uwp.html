<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>A custom signaling solution | MixedReality-WebRTC Documentation </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="A custom signaling solution | MixedReality-WebRTC Documentation ">
    <meta name="generator" content="docfx 2.55.0.0">
    
    <link rel="shortcut icon" href="../../mr-webrtc_icon.svg">
    <link rel="stylesheet" href="../../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../../styles/docfx.css">
    <link rel="stylesheet" href="../../styles/main.css">
    <meta property="docfx:navrel" content="../../toc.html">
    <meta property="docfx:tocrel" content="../toc.html">
    
    <meta property="docfx:rel" content="../../">
    
  </head>
  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              
              <a class="navbar-brand" href="../../index.html">
                <img id="logo" class="svg" src="../../mr-webrtc_icon.png" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" id="branch-selector">
                <select name="branch"></select>
              </form>
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>
        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div class="container body-content">
        
        <div id="search-results">
          <div class="search-list"></div>
          <div class="sr-items">
            <p><i class="glyphicon glyphicon-refresh index-loading"></i></p>
          </div>
          <ul id="pagination"></ul>
        </div>
      </div>
      <div role="main" class="container body-content hide-when-search">
        
        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="">
<h1 id="a-custom-signaling-solution">A custom signaling solution</h1>

<p><em>Signaling</em> is the process of communicating with a remote endpoint with the intent of establishing a peer-to-peer connection. The WebRTC standard does not enforce any specific protocol or solution for WebRTC signaling; instead it simply states that some opaque messages must be transported between the remote peers by whatever mean the developer choses, its <em>signaling solution</em>.</p>
<p>The .NET Core Desktop tutorial <a href="helloworld-cs-signaling-core3.html">introduces the <code>NamedPipeSignaler</code></a>, a simple solution for local discovery based on named pipes. Unfortunately named pipes are not available on UWP, so this solution cannot be used. Instead, and also as an example of an alternate solutin, we rely in this tutorial on the existing <code>NodeDssSignaler</code> already used by the <code>TestAppUWP</code> sample app and the Unity integration. This requires a little bit more setup, described in details in the Unity tutorial.</p>
<div class="NOTE">
<h5>Note</h5>
<p>The <code>NodeDssSignaler</code> found in the <code>TestAppUWP</code> and the one found in the Unity integration use the same protocol and are compatible, but the code is different, the latter being based on Unity's <a href="https://docs.unity3d.com/ScriptReference/MonoBehaviour.html"><code>MonoBehaviour</code></a> component class. Here we use the former, which is written in pure C# and is independent of Unity.</p>
</div>
<h2 id="install">Install</h2>
<p>Like for the <code>VideoBridge</code> helper class, the easiest way to consume the <code>NodeDssSignaler</code> class in the <code>App1</code> sample app for UWP is to copy the <a href="https://github.com/microsoft/MixedReality-WebRTC/blob/master/examples/TestAppUwp/NodeDssSignaler.cs"><code>NodeDssSignaler.cs</code></a> file alongside the <code>App1.csproj</code> project of the current tutorial, and add a reference to it in the project using right-click &gt; <strong>Add</strong> &gt; <strong>Existing Item...</strong> (or Shift+Alt+A).</p>
<p>The <code>NodeDssSignaler</code> class makes use of the <code>Newtonsoft.Json</code> package for JSON data serialization and deserialization. This module is available as a NuGet package.</p>
<ol>
<li><p>In the <em>Solution Explorer</em> panel, right click on the <strong>References</strong> item and select <strong>Manage NuGet Packages...</strong>.</p>
</li>
<li><p>In the <strong>Browse</strong> panel, search for the <code>Newtonsoft.Json</code> package, select the latest stable version, and click the <strong>Install</strong> button.</p>
</li>
</ol>
<p><img src="cs-uwp14.png" alt="Install the Newtonsoft.Json NuGet package"></p>
<div class="WARNING">
<h5>Warning</h5>
<p>Do not forget to start the <code>node-dss</code> signaling server. See <a href="../unity/helloworld-unity-connection.html#configuring-the-nodedsssignaler">the detailed explanations in the Unity turorial</a> about installing and starting it with NodeJS. In this tutorial we choose the <em>local peer ID</em> to be the string &quot;<code>App1</code>&quot;, and the <em>remote peer ID</em> is the value we will assign below to the <code>NodeDssSignaler.RemotePeerId</code> field.</p>
</div>
<h2 id="setup">Setup</h2>
<p>Continue editing the <code>MainPage.xaml.cs</code> file.</p>
<ol>
<li><p>Import the <code>TestAppUwp</code> module. At the top of the <code>MainPage.xaml.cs</code> file add:</p>
<pre><code class="lang-cs">using TestAppUwp;
</code></pre>
</li>
<li><p>At the top of the <code>MainPage</code> class, create a <code>NodeDssSignaler</code> field.</p>
<pre><code class="lang-cs">private NodeDssSignaler _signaler;
</code></pre>
</li>
<li><p>In the <code>OnLoaded()</code> method, add some subscriptions to the signaling events.</p>
<pre><code class="lang-cs">_peerConnection.LocalSdpReadytoSend += Peer_LocalSdpReadytoSend;
_peerConnection.IceCandidateReadytoSend += Peer_IceCandidateReadytoSend;
</code></pre>
<p>The <a class="xref" href="../../api/Microsoft.MixedReality.WebRTC.PeerConnection.html#Microsoft_MixedReality_WebRTC_PeerConnection_LocalSdpReadytoSend"><code>LocalSdpReadytoSend</code></a> event is triggered after a call to <a class="xref" href="../../api/Microsoft.MixedReality.WebRTC.PeerConnection.html#Microsoft_MixedReality_WebRTC_PeerConnection_CreateOffer"><code>CreateOffer</code></a> or <a class="xref" href="../../api/Microsoft.MixedReality.WebRTC.PeerConnection.html#Microsoft_MixedReality_WebRTC_PeerConnection_CreateAnswer"><code>CreateAnswer</code></a> when WebRTC prepared the corresponding SDP message and signals the application the message is ready to be sent. The <a class="xref" href="../../api/Microsoft.MixedReality.WebRTC.PeerConnection.html#Microsoft_MixedReality_WebRTC_PeerConnection_IceCandidateReadytoSend"><code>IceCandidateReadytoSend</code></a> event similarly corresponds to ICE candidate messages generated by WebRTC, which the application needs to deliver to the remote peer.</p>
</li>
<li><p>Implement the event handlers, which simply format the SDP message for the signaler using the utility methods provided by the <code>NodeDssSignaler</code> class.</p>
<pre><code class="lang-cs">private void Peer_LocalSdpReadytoSend(SdpMessage message)
{
    var msg = NodeDssSignaler.FromSdpMessage(message);
    _signaler.SendMessageAsync(msg);
}

private void Peer_IceCandidateReadytoSend(IceCandidate iceCandidate)
{
    var msg = NodeDssSignaler.FromIceCandidate(iceCandidate);
    _signaler.SendMessageAsync(msg);
}
</code></pre>
</li>
<li><p>Continue appending to the <code>OnLoaded()</code> method to initialize and start the signaler.</p>
<pre><code class="lang-cs">// Initialize the signaler
_signaler = new NodeDssSignaler()
{
    HttpServerAddress = &quot;http://127.0.0.1:3000/&quot;,
    LocalPeerId = &quot;App1&quot;,
    RemotePeerId = &quot;&lt;input the remote peer ID here&gt;&quot;,
};
_signaler.OnMessage += async (NodeDssSignaler.Message msg) =&gt;
{
    switch (msg.MessageType)
    {
        case NodeDssSignaler.Message.WireMessageType.Offer:
            // Wait for the offer to be applied
            await _peerConnection.SetRemoteDescriptionAsync(msg.ToSdpMessage());
            // Once applied, create an answer
            _peerConnection.CreateAnswer();
            break;

        case NodeDssSignaler.Message.WireMessageType.Answer:
            // No need to await this call; we have nothing to do after it
            _peerConnection.SetRemoteDescriptionAsync(msg.ToSdpMessage());
            break;

        case NodeDssSignaler.Message.WireMessageType.Ice:
            _peerConnection.AddIceCandidate(msg.ToIceCandidate());
            break;
    }
};
_signaler.StartPollingAsync();
</code></pre>
<div class="WARNING">
<h5>Warning</h5>
<p>Take care to set the value of the <code>RemotePeerId</code> field of the <code>NodeDssSignaler</code> to the remote peer's ID, otherwise the signaling will not work. Similarly, this tutorial arbitrarily uses <code>App1</code> as the local peer ID for the application; this value needs to be set as the remote peer's ID when configuring the remote peer signaler. See <a href="../unity/helloworld-unity-connection.html#configuring-the-nodedsssignaler">the explanations in the Unity turorial</a> for more details.</p>
</div>
</li>
<li><p>In the <code>App_Suspending()</code> event handler, stop the signaler and clean-up the resources.</p>
<pre><code class="lang-cs">if (_signaler != null)
{
    _signaler.StopPollingAsync();
    _signaler = null;
}
</code></pre>
</li>
</ol>
<p>At this point the sample app is ready to establish a connection.</p>
<hr>
<p>Next : <a href="helloworld-cs-connection-uwp.html">Establishing a WebRTC connection</a></p>
</article>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <div class="contribution">
                <ul class="nav">
                  <li>
                    <a href="https://github.com/microsoft/MixedReality-WebRTC/blob/master/docs/manual/cs/helloworld-cs-signaling-uwp.md/#L1" class="contribution-link">Improve this Doc</a>
                  </li>
                </ul>
              </div>
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
              <!-- <p><a class="back-to-top" href="#top">Back to top</a><p> -->
              </nav>
            </div>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            
            <span>Generated by <strong>DocFX</strong></span>
          </div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="../../styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="../../styles/docfx.js"></script>
    <script type="text/javascript" src="../../styles/branches.gen.js"></script>
    <script type="text/javascript" src="../../styles/branch-selector.js"></script>
    <script type="text/javascript" src="../../styles/main.js"></script>
  </body>
</html>
