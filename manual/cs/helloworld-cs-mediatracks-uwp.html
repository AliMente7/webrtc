<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Add local media tracks | MixedReality-WebRTC Documentation </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="Add local media tracks | MixedReality-WebRTC Documentation ">
    <meta name="generator" content="docfx 2.48.0.0">
    
    <link rel="shortcut icon" href="../../mr-webrtc_icon.svg">
    <link rel="stylesheet" href="../../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../../styles/docfx.css">
    <link rel="stylesheet" href="../../styles/main.css">
    <meta property="docfx:navrel" content="../../toc.html">
    <meta property="docfx:tocrel" content="../toc.html">
    
    <meta property="docfx:rel" content="../../">
    
  </head>
  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              
              <a class="navbar-brand" href="../../index.html">
                <img id="logo" class="svg" src="../../mr-webrtc_icon.png" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" id="branch-selector">
                <select name="branch"></select>
              </form>
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>
        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div class="container body-content">
        
        <div id="search-results">
          <div class="search-list"></div>
          <div class="sr-items">
            <p><i class="glyphicon glyphicon-refresh index-loading"></i></p>
          </div>
          <ul id="pagination"></ul>
        </div>
      </div>
      <div role="main" class="container body-content hide-when-search">
        
        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="">
<h1 id="add-local-media-tracks">Add local media tracks</h1>

<p>Now that the peer connection is initialized, there are two possible paths, which can be both used:</p>
<ul>
<li>Immediately adding local audio and/or video tracks to the peer connection, so that they are available right away when the connection will be established with the remote peer.</li>
<li>Waiting for the connection to be established, and add the local media tracks after that.</li>
</ul>
<p>The first case is benefical in the sense that media tracks will be immediately negotiated during the connection establishing, without the need for an extra negotiation specific for the tracks. However it requires knowing in advance that the tracks are used. Conversely, the latter case corresponds to a scenario like late joining, where the user or the application can control when to add or remove local tracks, at the expense of requiring an extra network negotiation each time the list of tracks is changed.</p>
<p>In this tutorial, we add the local media tracks right away for simplicity.</p>
<h2 id="adding-the-tracks">Adding the tracks</h2>
<p>Continue editing the <code>MainPage.xaml.cs</code> file and append in the <code>OnLoaded</code> method the following:</p>
<ol>
<li><p>Create a new <a class="xref" href="../../api/Microsoft.MixedReality.WebRTC.LocalVideoTrack.html"><code>LocalVideoTrack</code></a> private variable.</p>
<pre><code class="lang-cs">LocalVideoTrack _localVideoTrack;
</code></pre>
</li>
<li><p>Use the <a class="xref" href="../../api/Microsoft.MixedReality.WebRTC.PeerConnection.html#Microsoft_MixedReality_WebRTC_PeerConnection_AddLocalVideoTrackAsync_Microsoft_MixedReality_WebRTC_PeerConnection_LocalVideoTrackSettings_"><code>AddLocalVideoTrackAsync()</code></a> method to add to the peer connection a local video track sending to the remote peer some video frames obtained from a local video capture device (webcam).</p>
<pre><code class="lang-cs">_localVideoTrack = await _peerConnection.AddLocalVideoTrackAsync();
</code></pre>
<p>This method optionally takes a <a class="xref" href="../../api/Microsoft.MixedReality.WebRTC.PeerConnection.LocalVideoTrackSettings.html"><code>LocalVideoTrackSettings</code></a> object to configure the video capture. In this tutorial, we leave that object out and use the default settings, which will open the first available webcam with its default resolution and framerate. This is generally acceptable, although on mobile devices like HoloLens you probably want to limit the resolution and framerate to reduce the power consumption and save on battery.</p>
</li>
<li><p>Use the <a class="xref" href="../../api/Microsoft.MixedReality.WebRTC.PeerConnection.html#Microsoft_MixedReality_WebRTC_PeerConnection_AddLocalAudioTrackAsync"><code>AddLocalAudioTrackAsync()</code></a> method to add to the peer connection a local audio track sending to the remote peer some audio frames obtained from a local audio capture device (microphone).</p>
<pre><code class="lang-cs">await _peerConnection.AddLocalAudioTrackAsync();
</code></pre>
<p>Unlike for the video track, the audio track currently does not offer any configuration option, and will always use the first available audio capture device.</p>
</li>
</ol>
<p>At this point, if you run the application again, there is no visible difference, except some extra delay to open the audio and video devices; this delay varies greatly depending on the number of capture devices on the host machine, but is generally within a few seconds too, sometimes much less. Additionally, if the webcam or microphone have a LED indicating recording, it should turn ON when the capture device starts recording. But the captured audio and video are not visible. This is because the audio and video tracks are capturing frames from the webcam and microphone, to be sent later to the remote peer once connected to it, but there is no local rendering by default.</p>
<h2 id="importing-the-videobridge-utility">Importing the <code>VideoBridge</code> utility</h2>
<p>In order to display the local webcam feed as a feedback for the user, we need to collect the video frames captured by WebRTC via the webcam, and display them locally in the app using whichever technology we choose. In this tutorial for simplicity we use the <a class="xref" href="https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.mediaplayerelement">MediaPlayerElement</a> XAML control, which is based on the Media Foundation framework. And to keep things simple, we also use <a href="https://github.com/microsoft/MixedReality-WebRTC/blob/master/examples/TestAppUwp/Video/VideoBridge.cs">the <code>TestAppUwp.Video.VideoBridge</code> helper class</a> from the <code>TestAppUWP</code> sample application provided by MixedReality-WebRTC, which bridges a raw source of frames (WebRTC) with the <a class="xref" href="https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.mediaplayerelement">MediaPlayerElement</a>, taking care of the interoperability details for us.</p>
<p>The <a href="https://github.com/microsoft/MixedReality-WebRTC/blob/master/examples/TestAppUwp/Video/VideoBridge.cs"><code>TestAppUwp.Video.VideoBridge</code></a> helper class makes use of the <a href="https://github.com/microsoft/MixedReality-WebRTC/blob/master/examples/TestAppUwp/Video/StreamSamplePool.cs"><code>StreamSamplePool</code></a> class, which also needs to be imported. For the sake of simplicity in this tutorial we simply copy those two files.</p>
<ol>
<li><p>Download the <a href="https://github.com/microsoft/MixedReality-WebRTC/blob/master/examples/TestAppUwp/Video/VideoBridge.cs"><code>VideoBridge.cs</code></a> and <a href="https://github.com/microsoft/MixedReality-WebRTC/blob/master/examples/TestAppUwp/Video/StreamSamplePool.cs"><code>StreamSamplePool.cs</code></a> from the MixedReality-WebRTC repository, or copy them from a local clone of the repository, and paste them into the current tutorial project.</p>
</li>
<li><p>Add a reference to the <code>App1.csproj</code> project by right-clicking on the project in the <em>Solution Explorer</em> panel and selecting <strong>Add</strong> &gt; <strong>Existing Item...</strong> (or using Shift+Alt+A), pointing the add dialog to the two newly copied files <code>VideoBridge.cs</code> and <code>StreamSamplePool.cs</code>.</p>
</li>
</ol>
<p><img src="cs-uwp13.png" alt="Import the video bridge into the C# project"></p>
<h2 id="editing-the-local-video-ui">Editing the local video UI</h2>
<p>Double-click on the <code>MainPage.xaml</code> (or right-click &gt; <strong>Open</strong>) to bring up the XAML visual editor of the <code>MainPage</code> page. The page is currently blank, similar to what is displayed when launching the application. We will add a video player to it.</p>
<p><img src="cs-uwp12.png" alt="XAML visual editor for the MainPage page"></p>
<p>The XAML visual editor allows editing the XAML user interface both via the visual top panel and via the XAML code in the bottom panel. Which approach is best is generally up to personal preference, although for discoverability it is easier to drag and drop controls from the <strong>Toolbox</strong> panel. In this tutorial however we make use of the <a class="xref" href="https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.mediaplayerelement">MediaPlayerElement</a> control which is not available from the toolbox.</p>
<p>Edit the <code>MainPage.xaml</code> code from the <strong>XAML</strong> panel of the editor, and inside the <code>&lt;Grid&gt;</code> element add a <code>&lt;MediaPlayerElement&gt;</code> node:</p>
<pre><code class="lang-xml">&lt;Grid&gt;
  &lt;MediaPlayerElement x:Name=&quot;localVideoPlayerElement&quot; /&gt;
&lt;/Grid&gt;
</code></pre>
<p>This will create a media player which covers the entire surface of the application window.</p>
<h2 id="bridging-the-track-and-its-rendering">Bridging the track and its rendering</h2>
<p>The key link between a raw source of video frames and the Media Foundation pipeline is the <a class="xref" href="https://docs.microsoft.com/uwp/api/windows.media.core.mediastreamsource"><code>MediaStreamSource</code></a> class, which wraps an external video source to deliver raw frames directly to the media playback pipeline.</p>
<p>Get back to the associated <code>MainPage.xaml.cs</code> and continue editing:</p>
<ol>
<li><p>At the top of the file, import the following extra modules:</p>
<pre><code class="lang-cs">using TestAppUWP.Video;
using Windows.Media.Core;
using Windows.Media.Playback;
using Windows.Media.MediaProperties;
</code></pre>
</li>
<li><p>Create a new utility method <code>CreateI420VideoStreamSource()</code> which builds a <a class="xref" href="https://docs.microsoft.com/uwp/api/windows.media.core.mediastreamsource"><code>MediaStreamSource</code></a> instance to encaspulate a given video stream encoded in I420 format, which is the encoding in which WebRTC provides its raw video frames. This method will be reused later for the remote video too.</p>
<pre><code class="lang-cs">private MediaStreamSource CreateI420VideoStreamSource(
    uint width, uint height, int framerate)
{
    if (width == 0)
    {
        throw new ArgumentException(&quot;Invalid zero width for video.&quot;, &quot;width&quot;);
    }
    if (height == 0)
    {
        throw new ArgumentException(&quot;Invalid zero height for video.&quot;, &quot;height&quot;);
    }
    // Note: IYUV and I420 have same memory layout (though different FOURCC)
    // https://docs.microsoft.com/en-us/windows/desktop/medfound/video-subtype-guids
    var videoProperties = VideoEncodingProperties.CreateUncompressed(
        MediaEncodingSubtypes.Iyuv, width, height);
    var videoStreamDesc = new VideoStreamDescriptor(videoProperties);
    videoStreamDesc.EncodingProperties.FrameRate.Numerator = (uint)framerate;
    videoStreamDesc.EncodingProperties.FrameRate.Denominator = 1;
    // Bitrate in bits per second : framerate * frame pixel size * I420=12bpp
    videoStreamDesc.EncodingProperties.Bitrate = ((uint)framerate * width * height * 12);
    var videoStreamSource = new MediaStreamSource(videoStreamDesc);
    videoStreamSource.BufferTime = TimeSpan.Zero;
    videoStreamSource.SampleRequested += OnMediaStreamSourceRequested;
    videoStreamSource.IsLive = true; // Enables optimizations for live sources
    videoStreamSource.CanSeek = false; // Cannot seek live WebRTC video stream
    return videoStreamSource;
}
</code></pre>
</li>
</ol>
<p>The <code>CreateI420VideoStreamSource()</code> method references the <a class="xref" href="https://docs.microsoft.com/uwp/api/windows.media.core.mediastreamsource.samplerequested"><code>SampleRequested</code></a> event, which is invoked by the Media Foundation playback pipeline when it needs a new frame. We use the <code>VideoBridge</code> helper class to serve those frames.</p>
<ol>
<li><p>At the top of the <code>MainPage</code> class, define two new variables: a <a class="xref" href="https://docs.microsoft.com/uwp/api/windows.media.core.mediastreamsource"><code>MediaStreamSource</code></a> for wrapping the local video stream and exposing it to the Media Foundation playback pipeline, and a <a href="https://github.com/microsoft/MixedReality-WebRTC/blob/master/examples/TestAppUwp/Video/VideoBridge.cs"><code>VideoBridge</code></a> for managing the delivery of the video frames. The video bridge is initialized with a queue capacity of 3 frames, which is generally enough for local video as it is not affected by network latency.</p>
<pre><code class="lang-cs">private MediaStreamSource _localVideoSource;
private VideoBridge _localVideoBridge = new VideoBridge(3);
</code></pre>
</li>
<li><p>Implement the <code>OnMediaStreamSourceRequested()</code> callback using the video bridge. As we plan to reuse that callback for the remote video, the code finds the suitable video bridge based on the source which invoked the event.</p>
<pre><code class="lang-cs">private void OnMediaStreamSourceRequested(MediaStreamSource sender,
    MediaStreamSourceSampleRequestedEventArgs args)
{
    VideoBridge videoBridge;
    if (sender == _localVideoSource)
        videoBridge = _localVideoBridge;
    else
        return;
    videoBridge.TryServeVideoFrame(args);
}
</code></pre>
</li>
<li><p>In the <code>OnLoaded()</code> method where the local video track was created, subscribe to the <a class="xref" href="../../api/Microsoft.MixedReality.WebRTC.LocalVideoTrack.html#Microsoft_MixedReality_WebRTC_LocalVideoTrack_I420AVideoFrameReady"><code>I420AVideoFrameReady</code></a> event.</p>
<pre><code class="lang-cs"> _localVideoTrack = await _peerConnection.AddLocalVideoTrackAsync();
 _localVideoTrack.I420AVideoFrameReady += Peer_LocalI420AFrameReady;
</code></pre>
</li>
<li><p>Implement the event handler by enqueueing the newly captured video frames into the bridge, which will later deliver them when the Media Foundation playback pipeline requests them.</p>
<pre><code class="lang-cs">private void Peer_LocalI420AFrameReady(I420AVideoFrame frame)
{
    _localVideoBridge.HandleIncomingVideoFrame(frame);
}
</code></pre>
</li>
</ol>
<h2 id="starting-the-media-playback">Starting the media playback</h2>
<p>The last part is to actually start the playback pipeline when video frames start to be received from WebRTC. This is done lazily for two reasons:</p>
<ul>
<li>to avoid starving the Media Foundation playback pipeline if the WebRTC local video track takes some time to start delivering frames, which it generally does compared to the expectation of the playback pipeline.</li>
<li>to get access to the frame resolution, which is not otherwise available from WebRTC.</li>
</ul>
<p>Unfortunately at this time the capture framerate is not available, so we assume a framerate of 30 frames per second (FPS).</p>
<ol>
<li><p>At the top of the <code>MainPage</code> class, add a boolean field to indicate whether the local video is playing. This is protected by a lock, because the <a class="xref" href="../../api/Microsoft.MixedReality.WebRTC.LocalVideoTrack.html#Microsoft_MixedReality_WebRTC_LocalVideoTrack_I420AVideoFrameReady"><code>I420AVideoFrameReady</code></a> and the <a class="xref" href="https://docs.microsoft.com/uwp/api/windows.media.core.mediastreamsource.samplerequested"><code>SampleRequested</code></a> events can be fired in parallel from multiple threads.</p>
<pre><code class="lang-cs">private bool _localVideoPlaying = false;
private object _localVideoLock = new object();
</code></pre>
</li>
<li><p>Modify the <code>Peer_LocalI420AFrameReady()</code> event handler to start the media player when the first WebRTC frame arrives.</p>
<pre><code class="lang-cs">private void Peer_LocalI420FrameReady(I420AVideoFrame frame)
{
    lock (_localVideoLock)
    {
        if (!_localVideoPlaying)
        {
            _localVideoPlaying = true;

            // Capture the resolution into local variable useable from the lambda below
            uint width = frame.width;
            uint height = frame.height;

            // Defer UI-related work to the main UI thread
            RunOnMainThread(() =&gt;
            {
                // Bridge the local video track with the local media player UI
                int framerate = 30; // for lack of an actual value
                _localVideoSource = CreateI420VideoStreamSource(
                    width, height, framerate);
                var localVideoPlayer = new MediaPlayer();
                localVideoPlayer.Source = MediaSource.CreateFromMediaStreamSource(
                    _localVideoSource);
                localVideoPlayerElement.SetMediaPlayer(localVideoPlayer);
                localVideoPlayer.Play();
            });
        }
    }
    _localVideoBridge.HandleIncomingVideoFrame(frame);
}
</code></pre>
<p>Some of the work cannot be carried during the execution of this event handler, which is invoked from an unspecified worker thread, because access to XAML UI elements must be done exclusively on the main UI thread. Therefore we use a helper method which schedule this work for execution on that thread.</p>
<div class="NOTE">
<h5>Note</h5>
<p>The use of <code>_localVideoSource</code> from the <code>OnMediaStreamSourceRequested()</code> event handler is not protected by the <code>_localVideoLock</code> lock. This is because the event cannot be fired until well after the <code>_localVideoSource</code> has been assigned a new value, so there is no race condition concern here. And since <code>_localVideoSource</code> is not further modified, we avoid acquiring that lock in the <code>OnMediaStreamSourceRequested()</code> to reduce the chances of contention. The lock is actually not needed at all at this point, since <code>_localVideoPlaying</code> is also only modified in the current <code>Peer_LocalI420FrameReady()</code> event handler. But a typical application will provide some UI like a button to start and stop the local video, and therefore needs to synchronize access to <code>_localVideoPlaying</code> and <code>_localVideoSource</code>, at which point <code>OnMediaStreamSourceRequested()</code> will also need to acquire this lock.</p>
</div>
</li>
<li><p>Implement the <code>RunOnMainThread()</code> helper using the <a class="xref" href="https://docs.microsoft.com/uwp/api/windows.ui.core.corewindow.dispatcher#Windows_UI_Core_CoreWindow_Dispatcher"><code>Dispatcher</code></a> of the current window.</p>
<pre><code class="lang-cs">private void RunOnMainThread(Windows.UI.Core.DispatchedHandler handler)
{
    if (Dispatcher.HasThreadAccess)
    {
        handler.Invoke();
    }
    else
    {
        // Note: use a discard &quot;_&quot; to silence CS4014 warning
        _ = Dispatcher.RunAsync(Windows.UI.Core.CoreDispatcherPriority.Normal, handler);
    }
}
</code></pre>
</li>
<li><p>In the <code>App_Suspending()</code> event handler, clear the media player of the <code>localVideoPlayerElement</code> control so that it repaint itself and avoids keeping the last video frame when the video is turned off.</p>
<pre><code class="lang-cs">localVideoPlayerElement.SetMediaPlayer(null);
</code></pre>
</li>
</ol>
<p>At this point the <a class="xref" href="https://docs.microsoft.com/uwp/api/windows.ui.xaml.controls.mediaplayerelement">MediaPlayerElement</a> control and the WebRTC local video track are connected together. Launch the application again; the local webcam starts capturing video frame, which are displayed in the main window of the application.</p>
<hr>
<p>Next : <a href="helloworld-cs-signaling-uwp.html">A custom signaling solution</a></p>
</article>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <div class="contribution">
                <ul class="nav">
                  <li>
                    <a href="https://github.com/microsoft/MixedReality-WebRTC/blob/master/docs/manual/cs/helloworld-cs-mediatracks-uwp.md/#L1" class="contribution-link">Improve this Doc</a>
                  </li>
                </ul>
              </div>
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
              <!-- <p><a class="back-to-top" href="#top">Back to top</a><p> -->
              </nav>
            </div>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            
            <span>Generated by <strong>DocFX</strong></span>
          </div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="../../styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="../../styles/docfx.js"></script>
    <script type="text/javascript" src="../../styles/branch-selector.js"></script>
    <script type="text/javascript" src="../../styles/main.js"></script>
  </body>
</html>
