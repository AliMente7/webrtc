<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>A custom signaling solution | MixedReality-WebRTC Documentation </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="A custom signaling solution | MixedReality-WebRTC Documentation ">
    <meta name="generator" content="docfx 2.55.0.0">
    
    <link rel="shortcut icon" href="../../mr-webrtc_icon.png">
    <link rel="stylesheet" href="../../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../../styles/docfx.css">
    <link rel="stylesheet" href="../../styles/main.css">
    <meta property="docfx:navrel" content="../../toc.html">
    <meta property="docfx:tocrel" content="../toc.html">
    
    <meta property="docfx:rel" content="../../">
    
  </head>
  <body data-spy="scroll" data-target="#affix" data-offset="120" data-uid="">
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              
              <a class="navbar-brand" href="../../index.html">
                <img id="logo" class="svg" src="../../mr-webrtc_icon.png" alt="MixedReality-WebRTC">
                <span>MixedReality-WebRTC</span>
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" id="branch-selector">
                <select name="branch"></select>
              </form>
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>
        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div class="container body-content">
        
        <div id="search-results">
          <div class="search-list"></div>
          <div class="sr-items">
            <p><i class="glyphicon glyphicon-refresh index-loading"></i></p>
          </div>
          <ul id="pagination"></ul>
        </div>
      </div>
      <div role="main" class="container body-content hide-when-search">
        
        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="">
<h1 id="a-custom-signaling-solution">A custom signaling solution</h1>

<p><em>Signaling</em> is the process of communicating with a remote endpoint with the intent of establishing a peer-to-peer connection. The WebRTC standard does not enforce any specific protocol or solution for WebRTC signaling; instead it simply states that some opaque messages must be transported between the remote peers by whatever mean the developer choses, its <em>signaling solution</em>.</p>
<p>In general, the signaling solution involves a third-party server in addition of the two peers trying to connect to each other. Using a third-party server may seem counter-intuitive at first when dealing with peer-to-peer connection, but in general that third-party server is an easy-to-reach server (public IP) which acts as a relay and enables WebRTC to discover a direct route between the two peers even in complex network scenarios (one or both peers behind a NAT) where it would otherwise be impossible for the two peers to directly discover each other. The service provided by the signaling server is also sometimes referred to as some <em>discovery service</em> or <em>identity service</em> (because it makes the identity of each peer available to the other).</p>
<h2 id="namedpipesignaler">NamedPipeSignaler</h2>
<p>In this tutorial we use the <code>NamedPipeSignaler</code> found in <code>examples/TestNetCoreConsole/NamedPipeSignaler</code> in the GitHub repository. This is a simple signaling solution based as the name implies on named pipes, which allows local peer discovery and connection out of the box on a local host without any configuration. This is not a production-ready solution, but for this tutorial it has the benefit of being very simple, sidestepping any networking configuration and potential issue.</p>
<h3 id="install">Install</h3>
<p>The easiest way to consume the <code>NamedPipeSignaler</code> class in the <code>TestNetCoreConsole</code> sample app is to copy the <code>examples/TestNetCoreConsole/NamedPipeSignaler.cs</code> file alongside the <code>TestNetCoreConsole.csproj</code> project. This avoids the need for any reference setup in the project, or any other kind of project configuration.</p>
<h3 id="pipe-creation">Pipe creation</h3>
<p>There is no need to understand how the <code>NamedPipeSignaler</code> class works for this tutorial. But for the sake of curiosity, this is how the connection is established (the reader can skip to the <strong>Setup the signaler</strong> section below if not interested):</p>
<ul>
<li>Try to create a pipe server.
<ul>
<li>If that succeeds, then this peer is the first peer and will <em>act as server</em>.</li>
<li>If that fails, then another peer already created that pipe server, so this peer will <em>act as client</em>.</li>
</ul>
</li>
<li>If acting as server:
<ul>
<li>Wait for the remote peer to connect its client pipe to this server.</li>
<li>Create a <em>reverse</em> pipe client and connect to the <em>reverse</em> pipe server of the remote peer.</li>
</ul>
</li>
<li>If acting as client:
<ul>
<li>Connect to the pipe server created by the other peer.</li>
<li>Create a <em>reverse</em> pipe server, and wait for the server to connect back with its <em>reverse</em> pipe client.</li>
</ul>
</li>
<li>At this point, both peer have a client pipe for sending data and a server pipe for receiving data, and can communicate.</li>
<li>Start a background task to read incoming messages from the remote peer, and wait.</li>
</ul>
<p>We note here that despite WebRTC relying on peer-to-peer connection, the two peers are not strictly equal. This is not only due to the fact that this particular signaling solution is assymetric, but also to the assymetric nature of establishing a WebRTC connection. In general we refer to the peer initiating the connection as the <em>caller</em> and the other peer as the <em>callee</em>.</p>
<h2 id="setup-the-signaler">Setup the signaler</h2>
<p>Continue editing the <code>Program.cs</code> file and append the following:</p>
<ol>
<li><p>Create a signaler associated with the existing peer connection.</p>
<pre><code class="lang-cs">var signaler = new NamedPipeSignaler.NamedPipeSignaler(pc, &quot;testpipe&quot;);
</code></pre>
</li>
<li><p>Connect handlers to the signaler's messages, and forward them to the peer connection.</p>
<pre><code class="lang-cs">signaler.SdpMessageReceived += async (SdpMessage message) =&gt; {
    // Note: we use 'await' to ensure the remote description is applied
    // before calling CreateAnswer(). Failing to do so will prevent the
    // answer from being generated, and the connection from establishing.
    await pc.SetRemoteDescriptionAsync(message);
    if (message.Type == SdpMessageType.Offer)
    {
        pc.CreateAnswer();
    }
};

signaler.IceCandidateReceived += (IceCandidate candidate) =&gt; {
    pc.AddIceCandidate(candidate);
};
</code></pre>
<p>In addition of forwarding the messages to the peer connection, we also automatically call <a class="xref" href="../../api/Microsoft.MixedReality.WebRTC.PeerConnection.html#Microsoft_MixedReality_WebRTC_PeerConnection_CreateAnswer"><code>PeerConnection.CreateAnswer()</code></a> on the <em>callee</em> peer as soon as the remote offer received from the <em>caller</em> has been applied. This ensures the minimum amount of latency, but also means the <em>callee</em> automatically accepts any incoming call. Alternatively, a typical application would display some user feedback and wait for confirmation to accept the incoming call.</p>
</li>
<li><p>Start the signaler and connect it to the remote peer's signaler.</p>
<pre><code class="lang-cs">await signaler.StartAsync();
</code></pre>
<p>This last call will block until the two signalers are connected with each other.</p>
</li>
</ol>
<p>At this point the signaler is functional. However as pointed above it will wait for a second instance of the <code>TestNetCoreConsole</code> app to connect. Currently unless the local machine has at least 2 webcams and 2 microphones then this cannot work because both instances will attempt to capture the webcam and microphone, and one of them will fail to do so and terminate before the program even reach the point where the signaler starts.</p>
<h2 id="optional-audio-and-video-capture">Optional audio and video capture</h2>
<p>In order to test the signaler with 2 instances of <code>TestNetCoreConsole</code> and a single microphone and webcam, we need one of those instances <em>not</em> to attempt to open the audio and video capture devices. For this, we had some command-line arguments to control the audio and video capture.</p>
<p>Continue editing the <code>Program.cs</code> file:</p>
<ol>
<li><p>At the top of the <code>Main</code> function, check if the audio and video capture arguments are present on the command-line arguments provided by the user. We name those arguments <code>-v</code>/<code>--video</code> to enable video capture, and <code>-a</code>/<code>--audio</code> to enable audio capture.</p>
<pre><code class="lang-cs">bool needVideo = Array.Exists(args, arg =&gt; (arg == &quot;-v&quot;) || (arg ==    &quot;--video&quot;));
bool needAudio = Array.Exists(args, arg =&gt; (arg == &quot;-a&quot;) || (arg ==    &quot;--audio&quot;));
</code></pre>
</li>
<li><p>Wrap the calls to <code>AddLocal(Audio|Video)TrackAsync</code> into <code>if</code> blocks using the boolean just defined. We also print some console message, so that the user can confirm whether the flags were indeed taken into account. This is useful to avoid mistakes since we will be running 2 instances of the app, one with the flags and one without. We also move the code for the transeivers inside that block.</p>
<pre><code class="lang-cs">// Record video from local webcam, and send to remote peer
if (needVideo)
{
    Console.WriteLine(&quot;Opening local webcam...&quot;);
    localVideoTrack = await LocalVideoTrack.CreateFromDeviceAsync();
    videoTransceiver = pc.AddTransceiver(MediaKind.Video);
    videoTransceiver.DesiredDirection = Transceiver.Direction.SendReceive;
    videoTransceiver.LocalVideoTrack = localVideoTrack;
}

// Record audio from local microphone, and send to remote peer
if (needAudio)
{
    Console.WriteLine(&quot;Opening local microphone...&quot;);
    localAudioTrack = await LocalAudioTrack.CreateFromDeviceAsync();
    audioTransceiver = pc.AddTransceiver(MediaKind.Audio);
    audioTransceiver.DesiredDirection = Transceiver.Direction.SendReceive;
    audioTransceiver.LocalAudioTrack = localAudioTrack;
}
</code></pre>
</li>
</ol>
<h2 id="establishing-a-signaler-connection">Establishing a signaler connection</h2>
<p>At this point the sample app is ready to establish a <em>signaler</em> connection. That is, 2 instances of the <code>TestNetCoreConsole</code> app can be launched, and their <code>NamedPipeSignaler</code> instances will connect to each other. Note however that we are not done yet with the peers, so the WebRTC peer-to-peer connection itself will not be established yet.</p>
<p>Start 2 instances of the sample app:</p>
<ul>
<li>one with the audio/video flags, the <em>capturer</em></li>
<li>one without any flag, the <em>receiver</em></li>
</ul>
<p><strong>Terminal #1 (capturer)</strong></p>
<pre><code class="lang-shell">dotnet run TestNetCoreConsole -- --audio --video
</code></pre>
<p><strong>Terminal #2 (receiver)</strong></p>
<pre><code class="lang-shell">dotnet run TestNetCoreConsole
</code></pre>
<p>The two terminals should print some messages and eventually indicate that the signaler connection was successful:</p>
<pre><code class="lang-shell">Signaler connection established.
</code></pre>
<p><img src="cs5.png" alt="Signaler connected"></p>
<hr>
<p>Next : <a href="helloworld-cs-connection-core3.html">Establishing a WebRTC connection</a></p>
</article>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <div class="contribution">
                <ul class="nav">
                  <li>
                    <a href="https://github.com/microsoft/MixedReality-WebRTC/blob/master/docs/manual/cs/helloworld-cs-signaling-core3.md/#L1" class="contribution-link">Improve this Doc</a>
                  </li>
                </ul>
              </div>
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
              <!-- <p><a class="back-to-top" href="#top">Back to top</a><p> -->
              </nav>
            </div>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            
            <span>Generated by <strong>DocFX</strong></span>
          </div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="../../styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="../../styles/docfx.js"></script>
    <script type="text/javascript" src="../../styles/branches.gen.js"></script>
    <script type="text/javascript" src="../../styles/branch-selector.js"></script>
    <script type="text/javascript" src="../../styles/main.js"></script>
  </body>
</html>
