<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Establishing a connection | MixedReality-WebRTC Documentation </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="Establishing a connection | MixedReality-WebRTC Documentation ">
    <meta name="generator" content="docfx 2.56.7.0">
    
    <link rel="shortcut icon" href="../../mr-webrtc_icon.png">
    <link rel="stylesheet" href="../../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../../styles/docfx.css">
    <link rel="stylesheet" href="../../styles/main.css">
    <meta property="docfx:navrel" content="../../toc.html">
    <meta property="docfx:tocrel" content="../toc.html">
    
    <meta property="docfx:rel" content="../../">
    
  </head>
  <body data-spy="scroll" data-target="#affix" data-offset="120" data-uid="">
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              
              <a class="navbar-brand" href="../../index.html">
                <img id="logo" class="svg" src="../../mr-webrtc_icon.png" alt="MixedReality-WebRTC">
                <span>MixedReality-WebRTC</span>
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" id="branch-selector">
                <select name="branch"></select>
              </form>
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>
        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div class="container body-content">
        
        <div id="search-results">
          <div class="search-list">Search Results for <span></span></div>
          <div class="sr-items">
            <p><i class="glyphicon glyphicon-refresh index-loading"></i></p>
          </div>
          <ul id="pagination" data-first="First" data-prev="Previous" data-next="Next" data-last="Last"></ul>
        </div>
      </div>
      <div role="main" class="container body-content hide-when-search">
        
        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="">
<h1 id="establishing-a-connection">Establishing a connection</h1>

<p>Now that we have both media senders and receivers, we can attempt to establish a connection with a remote peer.</p>
<p>There are a few requirements for this:</p>
<ul>
<li>We need 2 instances of the application running at the same time. Unfortunately the Unity Editor cannot be opened twice with the same project. As a workaround, we can build and deploy a standalone app on a device, even locally on the developer machine. Alternatively, we can use a second computer running another instance of the Unity Editor with an exact copy of this Unity project. The later is easier because we can still modify the project.</li>
<li>The <code>NodeDssSignaler</code> component needs to be configured to know which remote peer to expect. This is due to the fact that this is a simple, easy, and <strong>not production-ready</strong> solution which does not offer any functionality to discover and select a remote peer. Instead it uses strings to identify the two peers. We can chose any two different strings.</li>
</ul>
<div class="WARNING">
<h5>Warning</h5>
<p>When deploying to multiple devices, remember to change the IP address of the <code>node-dss</code> server to the IP address of the host machine in the <a class="xref" href="../../api/Microsoft.MixedReality.WebRTC.Unity.NodeDssSignaler.html"><code>NodeDssSignaler</code></a> component, instead of the default <code>127.0.0.1</code>.</p>
</div>
<h2 id="configuring-the-nodedsssignaler">Configuring the <code>NodeDssSignaler</code></h2>
<p>The <a class="xref" href="../../api/Microsoft.MixedReality.WebRTC.Unity.NodeDssSignaler.html"><code>NodeDssSignaler</code></a> has a <strong>Remote Peer Id</strong> property which contains the string identifying the remote peer to connect with. This should be filled with the identifier of the remote peer. The easiest way to obtain this identifier is to press <strong>Play</strong> and wait for the local signaler to start polling our <code>node-dss</code> server. If the server was started with the <code>DEBUG=*dss</code> environment variable set, it will output for each web request a message containing the identifier of the peer.</p>
<ul>
<li>Download and install <code>Node.js</code> from <a href="https://nodejs.org/en/">the official website</a>.</li>
<li>Clone the <code>node-dss</code> repository : <code>git clone https://github.com/bengreenier/node-dss.git</code></li>
<li>Configure and run it:</li>
</ul>
<pre><code class="lang-cmd">cd node-dss
set DEBUG=dss*
npm install
npm start
</code></pre>
<p>The <code>node-dss</code> server should start and wait for incoming connections. At this point we can press <strong>Play</strong> in the Unity Editor to start polling the <code>node-dss</code> server, and retrieve from the shell terminal its identifier string, which corresponds to the string generated by the implementation since we left the <a class="xref" href="../../api/Microsoft.MixedReality.WebRTC.Unity.NodeDssSignaler.html#Microsoft_MixedReality_WebRTC_Unity_NodeDssSignaler_LocalPeerId"><code>NodeDssSignaler.LocalPeerId</code></a> property empty:</p>
<p><img src="helloworld-unity-17.png" alt="Example of node-dss debug output"></p>
<p>This string needs to be pasted into the <strong>Remote Peer Id</strong> property of the <em>remote</em> peer on the other machine. Repeat the process on the remote machine and paste the result on the <strong>Remote Peer Id</strong> property of the local machine.</p>
<div class="WARNING">
<h5>Warning</h5>
<p>This step is critical, and there is no safeguard. If any of the two signalers doesn't have the correct value for the identifier of the remote peer then the peer connection will not be established.</p>
</div>
<p>Example:</p>
<table>
<thead>
<tr>
<th>Peer</th>
<th><code>LocalPeerId</code></th>
<th><code>RemotePeerId</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>Peer #1</td>
<td><code>PC1</code></td>
<td><code>MyMachine</code></td>
</tr>
<tr>
<td>Peer #2</td>
<td><code>MyMachine</code></td>
<td><code>PC1</code></td>
</tr>
</tbody>
</table>
<h2 id="starting-the-webrtc-connection">Starting the WebRTC connection</h2>
<p>Now that both peers are connected to the <code>node-dss</code> signaling server and can exchange some SDP messages, it is time to start an actual WebRTC connection.</p>
<p>The <code>VideoChatDemo</code> sample contains an example of creating a button and using the <code>NodeDssSignalerUI.cs</code> script to do that, but the task essentially boils down to one of the two peers, and one only, calling <a class="xref" href="../../api/Microsoft.MixedReality.WebRTC.Unity.PeerConnection.html#Microsoft_MixedReality_WebRTC_Unity_PeerConnection_StartConnection"><code>PeerConnection.StartConnection()</code></a>.</p>
<p>Once <a class="xref" href="../../api/Microsoft.MixedReality.WebRTC.Unity.PeerConnection.html#Microsoft_MixedReality_WebRTC_Unity_PeerConnection_StartConnection"><code>StartConnection()</code></a> is called, the local peer will asynchronously generate a new SDP offer message, and raise the <a class="xref" href="../../api/Microsoft.MixedReality.WebRTC.PeerConnection.html#Microsoft_MixedReality_WebRTC_PeerConnection_LocalSdpReadytoSend"><code>LocalSdpReadytoSend</code></a> event to let the signaler send it. The <a class="xref" href="../../api/Microsoft.MixedReality.WebRTC.Unity.NodeDssSignaler.html"><code>NodeDssSignaler</code></a> already handles this event and will automatically send it to the <code>node-dss</code> server. At this point the message should appear in the <code>node-dss</code> logs, which will buffer it until the remote peer polls for new data. After delivering the message, the remote peer will process it by calling <a class="xref" href="../../api/Microsoft.MixedReality.WebRTC.Unity.PeerConnection.html#Microsoft_MixedReality_WebRTC_Unity_PeerConnection_HandleConnectionMessageAsync_SdpMessage_"><code>HandleConnectionMessageAsync()</code></a>, and generally create an SDP answer message, which will travel back to the local peer via the <code>node-dss</code> server and be handled by <a class="xref" href="../../api/Microsoft.MixedReality.WebRTC.Unity.PeerConnection.html#Microsoft_MixedReality_WebRTC_Unity_PeerConnection_HandleConnectionMessageAsync_SdpMessage_"><code>HandleConnectionMessageAsync()</code></a> too. At this point if everything went right the WebRTC connection is established, and the audio and video tracks should start sending and receiving media data.</p>
</article>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <div class="contribution">
                <ul class="nav">
                  <li>
                    <a href="https://github.com/microsoft/MixedReality-WebRTC/blob/master/docs/manual/unity/helloworld-unity-connection.md/#L1" class="contribution-link">Improve this Doc</a>
                  </li>
                </ul>
              </div>
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
                <h5>In This Article</h5>
                <div></div>
              </nav>
            </div>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            
            <span>Generated by <strong>DocFX</strong></span>
          </div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="../../styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="../../styles/docfx.js"></script>
    <script type="text/javascript" src="../../styles/branches.gen.js"></script>
    <script type="text/javascript" src="../../styles/branch-selector.js"></script>
    <script type="text/javascript" src="../../styles/main.js"></script>
  </body>
</html>
