<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>A custom signaling solution | MixedReality-WebRTC Documentation </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="A custom signaling solution | MixedReality-WebRTC Documentation ">
    <meta name="generator" content="docfx 2.48.0.0">
    
    <link rel="shortcut icon" href="../../mr-webrtc_icon.svg">
    <link rel="stylesheet" href="../../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../../styles/docfx.css">
    <link rel="stylesheet" href="../../styles/main.css">
    <meta property="docfx:navrel" content="../../toc.html">
    <meta property="docfx:tocrel" content="../toc.html">
    
    <meta property="docfx:rel" content="../../">
    
  </head>
  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              
              <a class="navbar-brand" href="../../index.html">
                <img id="logo" class="svg" src="../../mr-webrtc_icon.png" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" id="branch-selector">
                <select name="branch"></select>
              </form>
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>
        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div class="container body-content">
        
        <div id="search-results">
          <div class="search-list"></div>
          <div class="sr-items">
            <p><i class="glyphicon glyphicon-refresh index-loading"></i></p>
          </div>
          <ul id="pagination"></ul>
        </div>
      </div>
      <div role="main" class="container body-content hide-when-search">
        
        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="">
<h1 id="a-custom-signaling-solution">A custom signaling solution</h1>

<p><em>Signaling</em> is the process of communicating with a remote endpoint with the intent of establishing a peer-to-peer connection. The WebRTC standard does not enforce any specific protocol or solution for WebRTC signaling; instead it simply states that some opaque messages must be transported between the remote peers by whatever mean the developer choses, its <em>signaling solution</em>.</p>
<h2 id="namedpipesignaler">NamedPipeSignaler</h2>
<p>In this chapter we use the <code>NamedPipeSignaler</code> found in <code>examples/NamedPipeSignaler</code>. This is a simple signaling solution based as the name implies on named pipes, which allows local peer discovery and connection out of the box on a local host without any configuration. This is not a production-ready solution, but for this tutorial it has the benefit of being very simple.</p>
<h3 id="install">Install</h3>
<p>The easiest way to consume the <code>NamedPipeSignaler</code> class in the <code>TestNetCoreConsole</code> sample app is to copy the <code>examples/NamedPipeSignaler/NamedPipeSignaler.cs</code> file alongside the <code>TestNetCoreConsole.csproj</code> project. This avoids the need for any reference setup in the project, or any other kind of configuration.</p>
<h3 id="pipe-creation">Pipe creation</h3>
<p>There is no need to understand how the <code>NamedPipeSignaler</code> class works for this tutorial. But for the sake of curiosity, this is how the connection is established (you can skip to the <strong>Setup the signaler</strong> section below if not interested):</p>
<ul>
<li>Try to create a pipe server.
<ul>
<li>If that succeeds, then this peer is the first peer and will <em>act as server</em>.</li>
<li>If that fails, then another peer already created that pipe server, so this peer will <em>act as client</em>.</li>
</ul>
</li>
<li>If acting as server:
<ul>
<li>Wait for the remote peer to connect its client pipe to this server.</li>
<li>Create a <em>reverse</em> pipe client and connect to the <em>reverse</em> pipe server of the remote peer.</li>
</ul>
</li>
<li>If acting as client:
<ul>
<li>Connect to the pipe server created by the other peer.</li>
<li>Create a <em>reverse</em> pipe server, and wait for the server to connect back with its <em>reverse</em> pipe client.</li>
</ul>
</li>
<li>At this point, both peer have a client pipe for sending data and a server pipe for receiving data, and can communicate.</li>
<li>Start a background task to read incoming messages from the remote peer, and wait.</li>
</ul>
<h2 id="setup-the-signaler">Setup the signaler</h2>
<p>Continue editing the <code>Program.cs</code> file and append the following:</p>
<ol>
<li><p>Create a signaler associated with the existing peer connection.</p>
<pre><code class="lang-cs">var signaler = new NamedPipeSignaler.NamedPipeSignaler(pc, &quot;testpipe&quot;);
</code></pre>
</li>
<li><p>Connect handlers to the signaler's messages, and forward them to the peer connection.</p>
<pre><code class="lang-cs">signaler.SdpMessageReceived += (string type, string sdp) =&gt; {
    pc.SetRemoteDescription(type, sdp);
    if (type == &quot;offer&quot;)
    {
        pc.CreateAnswer();
    }
};

signaler.IceCandidateReceived += (string candidate, int sdpMlineindex, string sdpMid) =&gt; {
    pc.AddIceCandidate(sdpMid, sdpMlineindex, candidate);
};
</code></pre>
</li>
<li><p>Start the signaler and connect it to the remote peer's signaler.</p>
<pre><code class="lang-cs">await signaler.StartAsync();
</code></pre>
<p>This last call will block until the two signalers are connected with each other.</p>
</li>
</ol>
<p>At this point the signaler is functional. However as pointed above it will wait for a second instance of the <code>TestNetCoreConsole</code> app to connect. But currently this cannot work, because both instances will attempt to capture the webcam and microphone, and one of them will fail to do so.</p>
<h2 id="optional-audio-and-video-capture">Optional audio and video capture</h2>
<p>In order to test the signaler with 2 instances of <code>TestNetCoreConsole</code>, we need one of those to <em>not</em> attempt to open the audio and video capture devices. For this, we had some command-line arguments to control the audio and video capture.</p>
<p>Continue editing the <code>Program.cs</code> file:</p>
<ol>
<li><p>At the top of the <code>Main</code> function, check if the audio and video capture arguments are present on the command-line arguments provided by the user. We name those arguments <code>-v</code>/<code>--video</code> to enable video capture, and <code>-a</code>/<code>--audio</code> to enable audio capture.</p>
<pre><code class="lang-cs">bool needVideo = Array.Exists(args, arg =&gt; (arg == &quot;-v&quot;) || (arg ==    &quot;--video&quot;));
bool needAudio = Array.Exists(args, arg =&gt; (arg == &quot;-a&quot;) || (arg ==    &quot;--audio&quot;));
</code></pre>
</li>
<li><p>Wrap the calls to <code>AddLocal(Audio|Video)TrackAsync</code> into <code>if</code> blocks using the boolean just defined. We also print some console message, so that the user can confirm whether the flags were indeed taken into account. This is useful to avoid mistakes since we will be running 2 instances of the app, one with the flags and one without.</p>
<pre><code class="lang-cs">// Record video from local webcam, and send to remote peer
if (needVideo)
{
    Console.WriteLine(&quot;Opening local webcam...&quot;);
    await pc.AddLocalVideoTrackAsync();
}

// Record audio from local microphone, and send to    peer
if (needAudio)
{
    Console.WriteLine(&quot;Opening local microphone...&quot;);
    await pc.AddLocalAudioTrackAsync();
}
</code></pre>
</li>
</ol>
<h2 id="establishing-a-signaler-connection">Establishing a signaler connection</h2>
<p>At this point the sample app is ready to establish a <em>signaler</em> connection. That is, 2 instances of the <code>TestNetCoreConsole</code> app can be launched, and their <code>NamedPipeSignaler</code> instances will connect together. Note however that we are not done yet with the peer connections, so the WebRTC peer-to-peer connection itself will not be established yet.</p>
<p>Start 2 instances of the sample app:</p>
<ul>
<li>one with the audio/video flags, the <em>capturer</em></li>
<li>one without any flag, the <em>receiver</em></li>
</ul>
<p><strong>Terminal #1 (capturer)</strong></p>
<pre><code>dotnet run TestNetCoreConsole -- --audio --video 
</code></pre>
<p><strong>Terminal #2 (receiver)</strong></p>
<pre><code>dotnet run TestNetCoreConsole
</code></pre>
<p>The two terminals should print some messages and eventually indicate that the connection was successful:</p>
<pre><code>Signaler connection established.
</code></pre>
<p><img src="cs5.png" alt="Signaler connected"></p>
<hr>
<p>Next : <a href="helloworld-cs-connection-core3.html">Establishing a WebRTC connection</a></p>
</article>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <div class="contribution">
                <ul class="nav">
                  <li>
                    <a href="https://github.com/microsoft/MixedReality-WebRTC/blob/1.0/docs/manual/cs/helloworld-cs-signaling-core3.md/#L1" class="contribution-link">Improve this Doc</a>
                  </li>
                </ul>
              </div>
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
              <!-- <p><a class="back-to-top" href="#top">Back to top</a><p> -->
              </nav>
            </div>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            
            <span>Generated by <strong>DocFX</strong></span>
          </div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="../../styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="../../styles/docfx.js"></script>
    <script type="text/javascript" src="../../styles/branch-selector.js"></script>
    <script type="text/javascript" src="../../styles/main.js"></script>
  </body>
</html>
