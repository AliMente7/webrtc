// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.

using System;
using System.Diagnostics;
using Microsoft.MixedReality.WebRTC.Interop;

namespace Microsoft.MixedReality.WebRTC
{
    /// <summary>
    /// Type of media track or media transceiver.
    /// </summary>
    /// <remarks>
    /// This is the projection of <c>mrsMediaKind</c> from the interop API.
    /// </remarks>
    public enum MediaKind : uint
    {
        /// <summary>
        /// Audio data.
        /// </summary>
        Audio = 0,

        /// <summary>
        /// Video data.
        /// </summary>
        Video = 1
    }

    /// <summary>
    /// Transceiver of a peer connection.
    /// 
    /// A transceiver is a media "pipe" connecting the local and remote peers, and used to transmit media
    /// data (audio or video) between the peers. The transceiver has a media flow direction indicating whether
    /// it is sending and/or receiving any media, or is inactive. When sending some media, the transceiver's
    /// local track is used as the source of that media. Conversely, when receiving some media, that media is
    /// delivered to the remote media track of the transceiver. As a convenience, both tracks can be null to
    /// avoid sending or ignore the received media, although this does not influence the media flow direction.
    /// 
    /// Transceivers are owned by the peer connection which creates them, and cannot be destroyed nor removed
    /// from the peer connection. They become invalid when the peer connection is closed, and should not be
    /// used after that.
    /// </summary>
    /// <remarks>
    /// This object corresponds roughly to the same-named notion in the WebRTC standard when using the
    /// Unified Plan SDP semantic.
    /// For Plan B, where RTP transceivers are not available, this wrapper tries to emulate the Unified Plan
    /// transceiver concept, and is therefore providing an abstraction over the WebRTC concept of transceivers.
    /// </remarks>
    /// <seealso cref="PeerConnection.Close"/>
    public class Transceiver
    {
        /// <summary>
        /// Direction of the media flowing inside the transceiver.
        /// </summary>
        public enum Direction : int
        {
            /// <summary>
            /// Transceiver is both sending to and receiving from the remote peer connection.
            /// </summary>
            SendReceive = 0,

            /// <summary>
            /// Transceiver is sending to the remote peer, but is not receiving any media from the remote peer.
            /// </summary>
            SendOnly = 1,

            /// <summary>
            /// Transceiver is receiving from the remote peer, but is not sending any media to the remote peer.
            /// </summary>
            ReceiveOnly = 2,

            /// <summary>
            /// Transceiver is inactive, neither sending nor receiving any media data.
            /// </summary>
            Inactive = 3,
        }

        /// <summary>
        /// A name for the transceiver, used for logging and debugging only.
        /// This can be set on construction if the transceiver is created by the local peer using
        /// <see cref="PeerConnection.AddTransceiver(MediaKind, TransceiverInitSettings)"/>, or will
        /// be generated by the implementation otherwise.
        /// There is no guarantee of unicity; this name is only informational.
        /// </summary>
        public string Name { get; } = string.Empty;

        /// <summary>
        /// Type of media carried by the transceiver, and by extension type of media of its tracks.
        /// </summary>
        public MediaKind MediaKind { get; }

        /// <summary>
        /// Peer connection this transceiver is part of.
        /// </summary>
        /// <seealso cref="WebRTC.PeerConnection"/>
        public PeerConnection PeerConnection { get; } = null;

        /// <summary>
        /// Index of the media line in the SDP protocol for this transceiver. This also corresponds
        /// to the index of the transceiver inside <see cref="PeerConnection.Transceivers"/>.
        /// </summary>
        /// <remarks>
        /// For Plan B, the media line index is not guaranteed by the SDP protocol, but this index
        /// is still valid as the index of the transceiver in the global collection of the peer connection
        /// <see cref="PeerConnection.Transceivers"/>.
        /// </remarks>
        public int MlineIndex { get; } = -1;

        /// <summary>
        /// Transceiver direction desired by the user.
        /// Once changed by the user, this value is the next direction that will be negotiated when
        /// calling <see cref="PeerConnection.CreateOffer"/> or <see cref="PeerConnection.CreateAnswer"/>.
        /// After the negotiation is completed, this is equal to <see cref="NegotiatedDirection"/>.
        /// </summary>
        /// <seealso cref="SetDirection(Direction)"/>
        /// <seealso cref="NegotiatedDirection"/>
        public Direction DesiredDirection
        {
            get { return _desiredDirection; }
            set { SetDirection(value); }
        }

        /// <summary>
        /// Last negotiated transceiver direction. This is equal to <see cref="DesiredDirection"/>
        /// after a negotiation is completed, but remains constant until the next SDP negotiation
        /// when changing the desired direction with <see cref="SetDirection(Direction)"/>.
        /// </summary>
        /// <seealso cref="DesiredDirection"/>
        /// <seealso cref="SetDirection(Direction)"/>
        public Direction? NegotiatedDirection { get; protected set; } = null;

        /// <summary>
        /// List of stream IDs associated with the transceiver.
        /// </summary>
        public string[] StreamIDs { get; }

        public MediaTrack LocalTrack => _localTrack;

        public LocalAudioTrack LocalAudioTrack
        {
            get { return (_localTrack as LocalAudioTrack); }
            set
            {
                if (MediaKind == MediaKind.Audio)
                {
                    SetLocalTrackImpl(value);
                }
                else
                {
                    throw new ArgumentException("Cannot assign local audio track as local track of video transceiver");
                }
            }
        }

        public LocalVideoTrack LocalVideoTrack
        {
            get { return (_localTrack as LocalVideoTrack); }
            set
            {
                if (MediaKind == MediaKind.Video)
                {
                    SetLocalTrackImpl(value);
                }
                else
                {
                    throw new ArgumentException("Cannot assign local video track as local track of audio transceiver");
                }
            }
        }

        public MediaTrack RemoteTrack => _remoteTrack;

        public RemoteAudioTrack RemoteAudioTrack
        {
            get { return (_remoteTrack as RemoteAudioTrack); }
            internal set { _remoteTrack = value; }
        }

        public RemoteVideoTrack RemoteVideoTrack
        {
            get { return (_remoteTrack as RemoteVideoTrack); }
            internal set { _remoteTrack = value; }
        }

        /// <summary>
        /// Backing field for <see cref="DesiredDirection"/>.
        /// </summary>
        /// <seealso cref="DesiredDirection"/>
        protected Direction _desiredDirection;

        /// <summary>
        /// Handle to the native transceiver object, valid until <see cref="CleanUpAfterNativeDestroyed"/>
        /// is called by the native implementation when the transceiver is destroyed as part
        /// of the peer connection closing.
        /// </summary>
        /// <remarks>
        /// In native land this is a <code>mrsTransceiverHandle</code>.
        /// </remarks>
        internal IntPtr _nativeHandle = IntPtr.Zero;

        /// <summary>
        /// Reference to the struct keeping the callback delegates alive while registered with
        /// the native implementation.
        /// This should be released with <see cref="Utils.ReleaseWrapperRef(IntPtr)"/>.
        /// </summary>
        /// <seealso cref="TransceiverInterop.RegisterCallbacks(Transceiver, out IntPtr)"/>
        private IntPtr _argsRef = IntPtr.Zero;

        private MediaTrack _localTrack = null;
        private MediaTrack _remoteTrack = null;

        /// <summary>
        /// Create a new transceiver associated with a given peer connection.
        /// </summary>
        /// <param name="handle">Handle to the native transceiver object.</param>
        /// <param name="mediaKind">The media kind of the transceiver and its tracks.</param>
        /// <param name="peerConnection">The peer connection owning this transceiver.</param>
        /// <param name="mlineIndex">The transceiver media line index in SDP.</param>
        /// <param name="name">The transceiver name.</param>
        /// <param name="streamIDs">Collection of stream IDs the transceiver is associated with, as set by the peer which created it.</param>
        /// <param name="initialDesiredDirection">Initial value to initialize <see cref="DesiredDirection"/> with.</param>
        internal Transceiver(IntPtr handle, MediaKind mediaKind, PeerConnection peerConnection, int mlineIndex,
            string name, string[] streamIDs, Direction initialDesiredDirection)
        {
            Debug.Assert(handle != IntPtr.Zero);
            _nativeHandle = handle;
            MediaKind = mediaKind;
            PeerConnection = peerConnection;
            MlineIndex = mlineIndex;
            Name = name;
            StreamIDs = streamIDs;
            _desiredDirection = initialDesiredDirection;
            TransceiverInterop.RegisterCallbacks(this, out _argsRef);
        }

        /// <summary>
        /// Change the media flowing direction of the transceiver.
        /// This triggers a renegotiation needed event to synchronize with the remote peer.
        /// </summary>
        /// <param name="newDirection">The new flowing direction.</param>
        /// <seealso cref="DesiredDirection"/>
        /// <seealso cref="NegotiatedDirection"/>
        public void SetDirection(Direction newDirection)
        {
            if (newDirection == _desiredDirection)
            {
                return;
            }
            var res = TransceiverInterop.Transceiver_SetDirection(_nativeHandle, newDirection);
            Utils.ThrowOnErrorCode(res);
            _desiredDirection = newDirection;
        }

        /// <summary>
        /// Change the local audio track sending data to the remote peer.
        /// 
        /// This detaches the previous local audio track if any, and attaches the new one instead.
        /// Note that the transceiver will only send some audio data to the remote peer if its
        /// negotiated direction includes sending some data and it has an attached local track to
        /// produce this data.
        /// 
        /// This change is transparent to the session, and does not trigger any renegotiation.
        /// </summary>
        /// <param name="track">The new local audio track attached to the transceiver, and used to
        /// produce audio data to send to the remote peer if the transceiver is sending.
        /// Passing <c>null</c> is allowed, and will detach the current track if any.</param>
        private void SetLocalTrackImpl(MediaTrack track)
        {
            if (track == _localTrack)
            {
                return;
            }

            var audioTrack = (track as LocalAudioTrack);
            var videoTrack = (track as LocalVideoTrack);
            if ((audioTrack != null) && (MediaKind != MediaKind.Audio))
            {
                throw new ArgumentException("Cannot set local audio track as local track of video transceiver");
            }
            if ((videoTrack != null) && (MediaKind != MediaKind.Video))
            {
                throw new ArgumentException("Cannot set local video track as local track of audio transceiver");
            }

            if (track != null)
            {
                if ((track.PeerConnection != null) && (track.PeerConnection != PeerConnection))
                {
                    throw new InvalidOperationException($"Cannot set track {track} of peer connection {track.PeerConnection} on transceiver {this} of different peer connection {PeerConnection}.");
                }
                uint res = Utils.MRS_E_UNKNOWN;
                if (audioTrack != null)
                {
                    res = TransceiverInterop.Transceiver_SetLocalAudioTrack(_nativeHandle, audioTrack._nativeHandle);
                }
                else if (videoTrack != null)
                {
                    res = TransceiverInterop.Transceiver_SetLocalVideoTrack(_nativeHandle, videoTrack._nativeHandle);
                }
                Utils.ThrowOnErrorCode(res);
            }
            else
            {
                // Note: Cannot pass null for SafeHandle parameter value (ArgumentNullException)
                uint res = Utils.MRS_E_UNKNOWN;
                if (MediaKind == MediaKind.Audio)
                {
                    res = TransceiverInterop.Transceiver_SetLocalAudioTrack(_nativeHandle, new LocalAudioTrackHandle());
                }
                else if (MediaKind == MediaKind.Video)
                {
                    res = TransceiverInterop.Transceiver_SetLocalVideoTrack(_nativeHandle, new LocalVideoTrackHandle());
                }
                Utils.ThrowOnErrorCode(res);
            }

            // Remove old track
            if (_localTrack != null)
            {
                Debug.Assert(_localTrack.Transceiver == this);
                Debug.Assert(_localTrack.PeerConnection == PeerConnection);
                _localTrack.Transceiver = null;
                _localTrack.PeerConnection = null;
                _localTrack = null;
            }

            // Add new track
            if (track != null)
            {
                Debug.Assert(track.Transceiver == null);
                Debug.Assert(track.PeerConnection == null);
                _localTrack = track;
                _localTrack.Transceiver = this;
                _localTrack.PeerConnection = PeerConnection;
            }
        }

        /// <summary>
        /// Callback invoked after the native transceiver has been destroyed, for clean-up.
        /// This is called by the peer connection when it closes, just before the C# transceiver
        /// object instance is destroyed.
        /// This replaces an hypothetical TransceiverRemoved callback, which doesn't exist to
        /// prevent confusion and underline the fact transceiver cannot be removed after being
        /// added to a peer connection, until that peer connection is closed and destroys them.
        /// </summary>
        internal void CleanUpAfterNativeDestroyed()
        {
            Debug.Assert(_localTrack == null);
            Debug.Assert(_remoteTrack == null);
            Debug.Assert(_nativeHandle != IntPtr.Zero);
            _nativeHandle = IntPtr.Zero;
            // No need (and can't) unregister callbacks, the native transceiver is already destroyed
            Utils.ReleaseWrapperRef(_argsRef);
            _argsRef = IntPtr.Zero;
        }

        /// <summary>
        /// Callback on internal implementation state changed to synchronize the cached state of this wrapper.
        /// </summary>
        /// <param name="negotiatedDirection">Current negotiated direction of the transceiver</param>
        /// <param name="desiredDirection">Current desired direction of the transceiver</param>
        internal void OnStateUpdated(Direction? negotiatedDirection, Direction desiredDirection)
        {
            _desiredDirection = desiredDirection;

            if (negotiatedDirection != NegotiatedDirection)
            {
                bool hadSendBefore = HasSend(NegotiatedDirection);
                bool hasSendNow = HasSend(negotiatedDirection);
                bool hadRecvBefore = HasRecv(NegotiatedDirection);
                bool hasRecvNow = HasRecv(negotiatedDirection);

                NegotiatedDirection = negotiatedDirection;

                if (hadSendBefore != hasSendNow)
                {
                    _localTrack?.OnMute(!hasSendNow);
                }
                if (hadRecvBefore != hasRecvNow)
                {
                    _remoteTrack?.OnMute(!hasRecvNow);
                }
            }
        }

        /// <summary>
        /// Check whether the given direction includes sending.
        /// </summary>
        /// <param name="dir">The direction to check.</param>
        /// <returns><c>true</c> if direction is <see cref="Direction.SendOnly"/> or <see cref="Direction.SendReceive"/>.</returns>
        public static bool HasSend(Direction dir)
        {
            return (dir == Direction.SendOnly) || (dir == Direction.SendReceive);
        }

        /// <summary>
        /// Check whether the given direction includes receiving.
        /// </summary>
        /// <param name="dir">The direction to check.</param>
        /// <returns><c>true</c> if direction is <see cref="Direction.ReceiveOnly"/> or <see cref="Direction.SendReceive"/>.</returns>
        public static bool HasRecv(Direction dir)
        {
            return (dir == Direction.ReceiveOnly) || (dir == Direction.SendReceive);
        }

        /// <summary>
        /// Check whether the given direction includes sending.
        /// </summary>
        /// <param name="dir">The direction to check.</param>
        /// <returns><c>true</c> if direction is <see cref="Direction.SendOnly"/> or <see cref="Direction.SendReceive"/>.</returns>
        public static bool HasSend(Direction? dir)
        {
            return dir.HasValue && ((dir == Direction.SendOnly) || (dir == Direction.SendReceive));
        }

        /// <summary>
        /// Check whether the given direction includes receiving.
        /// </summary>
        /// <param name="dir">The direction to check.</param>
        /// <returns><c>true</c> if direction is <see cref="Direction.ReceiveOnly"/> or <see cref="Direction.SendReceive"/>.</returns>
        public static bool HasRecv(Direction? dir)
        {
            return dir.HasValue && ((dir == Direction.ReceiveOnly) || (dir == Direction.SendReceive));
        }
    }
}
